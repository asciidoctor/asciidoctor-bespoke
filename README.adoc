= {project-name}
Dan Allen <https://github.com/mojavelinux>
// Settings:
:idprefix:
:idseparator: -
:toc: preamble
:toclevels: 2
ifdef::env-github[]
:!toc-title:
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
:warning-caption: :warn:
endif::[]
// Aliases:
:project-name: asciidoctor-bespoke
// URIs:
:uri-asciidoctor: http://asciidoctor.org
:uri-bespoke: http://markdalgleish.com/projects/bespoke.js/
:uri-bespoke-multimedia: https://github.com/opendevise/bespoke-multimedia
:uri-repo: https://github.com/asciidoctor/asciidoctor-bespoke
:uri-repo-file-prefix: {uri-repo}/blob/master/
ifdef::env-github[]
:uri-repo-file-prefix: link:
endif::[]
:uri-svgo: https://github.com/svg/svgo
:uri-yo-bespoke: https://github.com/bespokejs/generator-bespoke

A template-based converter for {uri-asciidoctor}[Asciidoctor] that produces the HTML component of a {uri-bespoke}[Bespoke.js] presentation from AsciiDoc.

== Overview

The {project-name} converter enables you to create HTML-based presentations while avoiding the tedium of writing HTML by hand.
This converter is responsible for generating the HTML component of a Bespoke.js presentation from an AsciiDoc document.
In other words, it allows you to use AsciiDoc in place of HTML (or an HTML template language like Jade) in your Bespoke.js project.

This converter works as part of the typical Gulp-based build for a Bespoke.js project.
You still need the build in order to manage dependencies, combine and "`browserify`" the JavaScript, compile the CSS, convert the AsciiDoc to HTML, run the preview server and publish the result.

This guide explains how to integrate the {project-name} converter into an existing Bespoke.js presentation.

== Prerequisites

In order to use this converter, you must satisify the prerequisites of both Bespoke.js and Asciidoctor.

For Bespoke.js::
. https://nodejs.org[Node.js] >= 0.12 footnote:[We strongly recommend using https://github.com/creationix/nvm[nvm] to manage Node.]
. http://gulpjs.com[Gulp] (command line interface only)

 $ npm install -g gulp-cli

For Asciidoctor::
+
[start=3]
. https://www.ruby-lang.org[Ruby] >= 2 footnote:[We strongly recommend using http://rvm.io[RVM] to manage Ruby.]
. http://bundler.io[Bundler]

 $ rvm use 2.3.0@main --install --create # (optional)
 $ gem install bundler

Naturally, you'll also need to setup a project for a Bespoke.js project just like you would any other Bespoke.js project.
For now, we recommend using the {uri-yo-bespoke}[Yeoman generator for Bespoke.js] to initialize your project.
In the future, we plan to provide a Yeoman generator that integrates {project-name} automatically.

== Integrating AsciiDoc into a Bespoke.js Project

Once you've initialized your Bespoke.js project, the next step is to replace Jade with AsciiDoc.

The first thing you'll need to do is add a [.path]_Gemfile_ to the root of the project.
Populate this file with the following content:

[source,ruby]
----
source 'https://rubygems.org'

gem 'asciidoctor', '1.5.4'
gem 'asciidoctor-bespoke', '1.0.0.alpha.1'
# To use the latest version from git, use the following line instead
#gem 'asciidoctor-bespoke', github: 'asciidoctor/asciidoctor-bespoke'
----

Next, run `bundle` from the root of the project to install the gems and their dependencies:

 $ bundle

The next step is to get the converter to generate the HTML from AsciiDoc when the rest of the presentation is built.
We'll repurpose the task that currently generates HTML from Jade for this purpose.

Open [.path]_package.json_ and add the following entries to the `devDependencies` section:

[source,js]
    "gulp-chmod": "^1.3.0",
    "gulp-exec": "^2.1.2",

Save the file and run `npm i` to install the new packages into your project:

 $ npm i

Open [.path]_gulpfile.js_ and add the following entries to the list of requires at the top:

[source,js]
  chmod = require('gulp-chmod'),
  exec = require('gulp-exec'),

In the same file, remove the existing `html` task and replace it with the one below:

[source,js]
gulp.task('html', ['clean:html'], function() {
  return gulp.src('src/index.adoc')
    .pipe(isDist ? through() : plumber())
    .pipe(exec('asciidoctor-bespoke -o - src/index.adoc', { pipeStdout: true }))
    .pipe(exec.reporter({ stdout: false }))
    .pipe(rename('index.html'))
    .pipe(chmod(644))
    .pipe(gulp.dest('dist'))
    .pipe(connect.reload());
});

Finally, if you want the build to watch the AsciiDoc file(s) for changes, look for the following line in the watch task:

[source,js]
  gulp.watch('src/**/*.jade', ['html']);

and replace it with:

[source,js]
  gulp.watch('src/**/*.adoc', ['html']);

The build is now ready.
But, before we can use our new task, we need to create slide content in AsciiDoc.

== Creating Slides in AsciiDoc

Writing AsciiDoc to create slides is pretty much the same as writing AsciiDoc for any another purpose.
There are two key differences.
You should write _a lot_ less content and you should only use one level of section headings.

=== Hello, Bespoke.js!

Here's an example of a simple presentation comprised of two slides, a title slide and one content slide.

[source,asciidoc]
----
= My Awesome Presentation
:!sectids:

== First Topic
----

Believe it or not, that's all it takes to make a presentation!

TIP: To see a complete example of a conventional-style presentation, check out the https://raw.githubusercontent.com/opendevise/bespoke-emulating-shower/master/src/index.adoc[AsciiDoc source] of the https://github.com/opendevise/bespoke-emulating-shower[Bespoke.js Emulating Shower] demo.

Here's a close approximation of the HTML the converter generates for the simple presentation shown above.

[source,html]
----
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>My Awesome Presentation</title>
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="stylesheet" href="build/build.css">
  </head>
  <body>
    <article class="deck">
      <section class="title">
        <h1>My Awesome Presentation</h1>
      </section>
      <section>
        <h2>First Topic</h2>
      </section>
    </article>
    <script src="build/build.js"></script>
  </body>
</html>
----

There are a few things you should notice:

* Each slide is represented by a `<section>`, which is created from each section title.
  - At runtime, Bespoke.js will add additional classes to each `<section>`, including `bespoke-slide`.
* The title slide has the class `title` and uses an `<h1>` heading.
* The section title for each content slide goes in an `<h2>` heading.
* The presentation is wrapped in an `<article>` element with the class `deck`.
  - At runtime, Bespoke.js will add additional classes to `<article>`, including `bespoke-parent`.
* The JavaScript and CSS to power the Bespoke.js presentation are loaded from the [.path]_build_ folder.

Of course, this is not a very interesting presentation, so let's dig a bit deeper.

=== The Title Slide

By default, the converter automatically creates a title slide from the document header and, if present, the preamble.
The document title (i.e., doctitle) becomes an `<h1>` heading.
The slide then incorporates information from the following attributes and nodes (subject to change):

* firstname (derived from the author attribute)
* lastname (derived from the author attribute)
* email (can be a URL)
* position
* organization
* twitter
* avatar (an image path relative to imagesdir)
* preamble content

NOTE: The title slide is a built-in transform mapped to the {uri-repo-file-prefix}templates/slim/slide_title.html.slim[slide_title.html.slim] template, which you can override.

Here's an example of an AsciiDoc document that generates a title slide that is fully populated:

[source,asciidoc]
----
= My Awesome Presentation
Author Name <http://example.com>
:organization: ACME Inc.
:position: Developer Advocate
:twitter: @asciidoctor
:avatar: author-avatar.png
:!sectids:

Additional content for title slide.

== First Topic
----

If you don't want the title slide to be created automatically, add the `noheader` attribute to the document header (or simply don't include a document header).

.A presentation without a title slide
[source,asciidoc]
----
= My Awesome Presentation
:!sectids:
:noheader:

== First Topic
----

=== Content Slides

Each content slide is created from a level-1 section title.
(Any levels below level-1 will simply be used as slide content).
The section title becomes an `<h2>` heading.
The remainder of the content in the section is placed below this heading.

Here's an example of a typical content slide with a heading:

.A slide with a heading and content
[source,asciidoc]
----
== Agenda
* Lesson
* Demo
* Discussion
----

While many of your slides may have a primary heading--perhaps as the only content on the slide--there are many slide types that don't require a heading.
You can indicate a slide without a heading by using `!` as the section title.
Here's an example:

.A slide with only content (i.e., an anonymous slide)
[source,asciidoc]
----
== !
image::chart.svg[]
----

If you want to give the slide a title, but just not show it, you can use the `conceal` option.

.A slide with a concealed heading
[source,asciidoc]
----
[%conceal]
= An Amazing Chart
image::chart.svg[]
----

A shorthand for the conceal option is to prefix the section title with a `!`.

.A shorthand for concealing the heading of a slide
[source,asciidoc]
----
= !An Amazing Chart
image::chart.svg[]
----

=== Speaker Slide

The converter includes an _experimental_ speaker slide, which you can place anywhere in the presentation.
To activate the speaker slide, create a section with an optional title and add the `transform=speaker` attribute.

[source,asciidoc]
----
[transform=speaker]
== Speaker
----

The speaker slide currently incorporates the following attributes:

* author
* position
* avatar (resolved relative to `imagesdir`)
* twitter
* email
* section content (if any)

NOTE: The speaker slide is a built-in transform mapped to the {uri-repo-file-prefix}templates/slim/slide_speaker.html.slim[slide_speaker.html.slim] template, which you can override.

Here's a rough approximation of the HTML generated for the speaker slide:

[source,html]
----
<section class="speaker">
  <header>
    <h2>Speaker Name</h2>
    <h3>Title</h3>
  </header>
  <figure class="image headshot">
    <img src="images/speaker-name.jpg" alt="Speaker Name">
  </figure>
  <p class="contact">@speaker | speaker@example.org</p>
</section>
----

CAUTION: The speaker slide is labeled as "`experimental`" because the HTML (content and layout) is likely to change as we learn the best way to organize the information.

=== Builds

One of the most common ways to control the rate at which content is shown in a presentation is to use builds.
A [.term]_build_ is a presentation technique in which fragments of content are revealed incrementally (usually triggered by an event such as a button press or time delay).
The AsciiDoc converter supports a variety of ways to add builds to your presentation.

The build mechanism itself is handled by a Bespoke.js plugin (e.g., bespoke-bullets) with the help of some CSS.
You'll then use metadata in the AsciiDoc file to indicate which content should participate in a build.

The two ways to enlist content in a build are the build option and the build attribute.
The first should handle most situations, while the latter enables you to fine-tune the behavior.

Before diving into that metadata, we first need to do a bit of configuration.

==== Build Configuration

Here's the JavaScript you'll need to add to your Bespoke.js configuration to activate the bespoke-bullets plugin to implement the behavior described in this section.

[source,js]
----
var bespoke = require('bespoke'),
  bullets = require('bespoke-bullets') // <1>
  ...

bespoke.from('article', [
  ...
  bullets('.build,.build-items>*:not(.build-items)'), // <2>
  ...
]);
----
<1> Load the bespoke-bullets plugin, assigning it to the `bullets` variable.
<2> Activate the bespoke-bullets plugin, using a CSS selector to query for buildable content.

Here's the CSS necessary to handle the visibility of build items and introduce several build effects.
You can customize the styles to your liking.

[source,css]
----
.bespoke-bullet:not(.bespoke-bullet-active) {
  visibility: hidden;
  pointer-events: none;
}

.fade .bespoke-bullet-active:not(.bespoke-bullet-current) {
  opacity: 0.1;
}

.vanish .bespoke-bullet-active:not(.bespoke-bullet-current) {
  visibility: hidden;
}
----

==== The build Option

Let's assume you have an unordered list on one of your slides and you want to reveal the items one-by-one.
Simply declare the build option on the list.

[source,asciidoc]
----
[%build]
* one
* two
* three
----

When the slide is first loaded, none of the items will be visible.
(The list container itself is the active build item).
Each time you press the button or key mapped to the "`next`" action, another item in the list will be revealed.
Past items will remain visible.

For content that doesn't have a container, such as a paragraph, you'll need to also add the build option to the section.

[source,asciidoc]
----
[%build]
== Another Topic
[%build]
A point about this topic.
----

The first build is automatically activated on slide entry.
Therefore, in order for the build on the paragraph to be deferred, the section title needs to be marked as the first build item.

At some point, you're likely to encounter a build permutation that can't be described using the option alone.
That's where the build attribute comes in.

==== The build Attribute

The build attribute is used to describe more complex build scenarios.
Right now, it supports the following values (though more may be added in the futrue):

self:: The block itself should be enlisted in the build, but not its children.
items:: The block's children should be enlisted in the build, but not the block itself.
self+items (equivalent to the build option):: The block and its children should be enlisted in the build.

Using the build attribute, we can tackle the following two cases:

* Show the list all at once.
* Show the first item in the list on slide entry.

Let's first look at how to show the list all at once on the first "`next`" action.

[source,asciidoc]
----
[%build]
== Another Topic
[build=self]
* one
* two
* three
----

The section title is the first build step, which is automatically activated on slide entry.
The next build step is the list as a whole.

Now, instead, let's reveal the items in the list one-by-one, but show the first item on slide entry.

[source,asciidoc]
----
== Another Topic
[build=items]
* one
* two
* three
----

In this case, the first item in the list is the auto-activated build step.
The next build step is the second item in the list.

As you can see, the build attribute gives you more fine-grained control over the build behavior.

=== Build Roles

You can use CSS to introduce additional build effects.
The effects supported out of the box are as follows:

* fade
* vanish
* replace (pending)

The CSS in the <<Build Configuration>> section implements these effects.

=== Canvas Image

The converter supports adding a background image to a slide while still preserving the semantics of the document.
If the first content in a slide is a block image, and that image has the role `canvas`, the converter will pluck that image block out of the content and promote it to the background image of the slide.

[source,asciidoc]
----
== !
[.canvas]
image::background-image.png[]
----

This feature makes it really easy to create image-only slides that take up the full screen.

By default, the image is configured to cover the slide surface.
If you want to force the image to be contained within the dimensions of the slide (while preserving the aspect ratio), you can add the role `contain`.

[source,asciidoc]
----
== !
[.contain.canvas]
image::background-image.png[]
----

// QUESTION should we allow the role to be specified on the slide instead of the image block?

=== Inserting SVGs

Just like for other image types, you use the block and inline image macros to add SVGs to your presentation (via AsciiDoc).
The difference comes in the fact that you can configure how the SVG is inserted into the HTML output.

The converter supports three ways of inserting an SVG into the HTML of a slide.
Each method is labeled below by the HTML element that is used:

`<img>`:: The SVG is linked as a rasterized image.
`<object>`:: The SVG is embedded as a live, interactive object (aka "`content document`").
`<svg>`:: The SVG is embedded directly into the HTML itself.

There are pros and cons of using each method (which is why the converter supports all three).
You can read more about the differences between these methods and their tradeoffs by studying the article https://www.smashingmagazine.com/2014/11/styling-and-animating-svgs-with-css/#embedding-svgs[Styling And Animating SVGs with CSS].

You declare an option on the image macro to control which method is used.
The option values are documented in the table below alongside the HTML element they emit.

.Options for controlling how the SVG is inserted into the HTML output
[cols="1,1m,2m"]
|===
|Option Name |HTML Element |AsciiDoc Example

|_none_ (default)
|<img>
|image::sample.svg[]

|interactive
|<object>
|[%interactive] +
image::sample.svg[]

|inline
|<svg>
|[%inline] +
image::sample.svg[]
|===

When using inline or interactive, the `viewBox` attribute must be defined on the root `<svg>` element in order for scaling to work properly
When using the inline option, if you specify a width or height on the image macro in AsciiDoc, the `width`, `height` and `style` attributes on the `<svg>` element will be removed.
If you're inserting an SVG using the inline method, we strongly recommend you optimize your SVG using a tool like {uri-svgo}[svgo].

TIP: The {uri-bespoke-multimedia}[bespoke-multimedia plugin] automatically adds the CSS class `active` to the root element of all "`interactive`" SVGs on the current slide, so long as the SVG is loaded from the same domain.

So which method should you choose?
It depends on how you're using the SVG.
Here are some rules of thumb to follow.

* Does the SVG have builds (aka bullets)? +
=> Use *inline*.
* Do you want the SVG content to be reachable by JavaScript from the main DOM? +
=> Use *inline*.
* Do you want the SVG content to inherit styles from the main DOM? +
=> Use *inline*.
* Does the SVG have CSS animations? +
=> Use *inline* or *interactive*.
  - If using interactive, you must use the {uri-bespoke-multimedia}[bespoke-multimedia plugin] to control the animations on slide entry and exit.
* Does the SVG reference custom fonts (i.e., webfonts)? +
=> Use *inline* or *interactive*.
  - If using interactive, you must link to the CSS that declares the fonts in the SVG file using an XML stylesheet declaration.
* Are you simply using the SVG as a static image (and it doesn't use custom fonts)? +
=> Use the *default*.

As you work with SVGs in your presentations, you'll become more comfortable making the decision about which method to employ given the circumstances.
It's only confusing the first couple of times.

=== Speaker Notes

The converter recognizes designated blocks containing speaker notes and incorporates them into the presentation as hidden elements.
The speaker notes are then displayed adjacent to the current slide in a presentation console.

You add speaker notes to a slide by nesting them in a sidebar (or admonition) block and adding the role `cue` to that block.
That block must then be placed at the end of the section for that slide.

[source,asciidoc]
----
== Topic
Visible content.

[.cue]
****
Topic is all around us.

Topic has the following benefits:

* Easy to use
* Easy to scale
* It's free!
****
----

To learn more about how to setup a presentation console, see the https://github.com/opendevise/bespoke-onstage[bespoke-onstage plugin].

=== Custom Transforms

While conversion from AsciiDoc is meant to save time when producing common slide types, there are cases when you find yourself going against the grain or exceeding the limits of what CSS can handle.
This situation is normal.
The truth is, certain slides require an HTML layout that is tailored to the content.
In these cases, you can use a custom transform.

You can delegate the conversion of a slide to a custom template by specifying the `transform` attribute.
The converter will then look for a template file that follows the pattern `slide_<transform>.html.slim`, where `<transform>` is the value of this attribute, inside the directory (or directories) specified by the `template_dir(s)` option.

Let's assume you want to create a custom presenter slide.
First, create a placeholder slide in the AsciiDoc and specify a custom transform.

[source,asciidoc]
----
[transform=presenter]
== Presenter
----

Next, create a file named [.path]_slide_presenter.html.slim_ in the directory that holds your templates.
The template is responsible for creating the `<section>` element for the slide.
(In fact, there's nothing stopping you from creating multiple slides).

.slide_presenter.html.slim
[source,slim]
----
section.presenter id=id class=role
  header
    h2=document.attr :author
    h3=document.attr :position
  figure.image.headshot
    img src=(image_uri document.attr :avatar) alt=(document.attr :author)
  - unless (_content = content).empty?
    =_content
----

Finally, when you invoke the converter, you must specify the location of the template file using the `-T` option:

 $ asciidoctor-bespoke -T src/templates src/index.adoc

Since you can access the entire document model of the parsed AsciiDoc in the template, you are free to pick and choose the content you want to add to the slide and in what order.

Let's look at an example that draws from the document model selectively.
Assume you want to create one slide per item in a list.

[source,asciidoc]
----
[transform=one_per_slide]
== !
* one
* two
* three
----

Here's a template that implements this behavior:

.slide_one_per_slide.html.slim
[source,slim]
----
- blocks.first.items.each do |_item|
  section
    p=_item.text
----

This template applied to the previous slide content will generate the following HTML:

[source,html]
----
<section>
  <p>one</p>
</section>
<section>
  <p>two</p>
</section>
<section>
  <p>three</p>
</section>
----

As you can see, there's no reason you have to stick to a 1-to-1 mapping between what is in the AsciiDoc file and the slide(s) you're generating.
The custom transform gives you the flexibility to layout the content on the slide exactly how you want.

////
any global options specific to the Bespoke.js converter

=== General HTML Customization (a custom template can be used for any node)

=== Enclose Option

=== Slice and Fit

=== Fit Image

=== Image Credit
////

== Building the Presentation

=== Standalone Version

You can build a static version of the slides using the following command:

 $ gulp

The files are built into the _dist_ directory.
You can then view the slides by navigating to _dist/index.html_ in your browser.

=== Local Preview Server

If you use the local preview server, the build will monitor the project files for changes and automatically refresh the presentation in the browser when a change is detected.
You can launch the preview server using:

 $ gulp serve

Once the server is running, you can view the slides by navigating to \http://localhost:8000 in your browser.

////
== Publishing

TODO
////

== Sample Presentations

* https://github.com/opendevise/bespoke-emulating-shower[Bespoke.js Emulating Shower]
* https://github.com/opendevise/bespoke-emulating-ioslides[Bespoke.js Emulating ioslides]
* https://github.com/opendevise/presentation-service-workers[Service Workers], a presentation by Hubert Sablonni√®re, ported from DZSlides
* https://github.com/opendevise/neo4j-slide-types[Neo4j Slide Types]

== About the Project

=== Authors

{project-name} was written by {email}[{author}].

=== Copyright

Copyright (C) 2015-2016 Dan Allen and the Asciidoctor Project.
Free use of this software is granted under the terms of the MIT License.

See the <<LICENSE#,LICENSE>> file for details.
